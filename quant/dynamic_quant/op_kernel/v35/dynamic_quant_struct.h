/**
 * Copyright (c) 2025 Huawei Technologies Co., Ltd.
 * This program is free software, you can redistribute it and/or modify it under the terms and conditions of 
 * CANN Open Software License Agreement Version 2.0 (the "License").
 * Please refer to the License for details. You may not use this file except in compliance with the License.
 * THIS SOFTWARE IS PROVIDED ON AN "AS IS" BASIS, WITHOUT WARRANTIES OF ANY KIND, EITHER EXPRESS OR IMPLIED, 
 * INCLUDING BUT NOT LIMITED TO NON-INFRINGEMENT, MERCHANTABILITY, OR FITNESS FOR A PARTICULAR PURPOSE.
 * See LICENSE in the root of the software repository for the full text of the License.
*/
/* !
 * \file dynamic_quant_struct.h
 * \brief
 */
#ifndef _DYNAMIC_QUANT_STRUCT_H_
#define _DYNAMIC_QUANT_STRUCT_H_

#include "ascendc/host_api/tiling/template_argument.h"

#ifndef TPL_USE_DB_FALSE

#define TPL_USE_DB_FALSE 0
#define TPL_USE_DB_TRUE 1

#define TPL_COMMON_FULL_LOAD 0
#define TPL_COMMON_LARGE_SHAPE 1
#define TPL_MOE_FULL_LOAD 2
#define TPL_MOE_LARGE_SHAPE 3
#define TPL_PER_TENSOR_FULL_LOAD 4
#define TPL_PER_TENSOR_LARGE_SHAPE 5
#define TPL_EMPTY_TENSOR 6

#define TPL_HAS_SMOOTH_FALSE 0
#define TPL_HAS_SMOOTH_TRUE 1

#define TPL_IS_SYMMERTRICAL_FALSE 0
#define TPL_IS_SYMMERTRICAL_TRUE 1

#endif

namespace DynamicQuantOp {
ASCENDC_TPL_ARGS_DECL(
    DynamicQuant,
    ASCENDC_TPL_UINT_DECL(useDb, 1, ASCENDC_TPL_UI_LIST,
                          TPL_USE_DB_FALSE, TPL_USE_DB_TRUE),
    ASCENDC_TPL_UINT_DECL(quantMode, 3, ASCENDC_TPL_UI_LIST,
                          TPL_COMMON_FULL_LOAD, TPL_COMMON_LARGE_SHAPE, TPL_MOE_FULL_LOAD,
                          TPL_MOE_LARGE_SHAPE, TPL_PER_TENSOR_FULL_LOAD, TPL_PER_TENSOR_LARGE_SHAPE, TPL_EMPTY_TENSOR),
    ASCENDC_TPL_UINT_DECL(hasSmooth, 1, ASCENDC_TPL_UI_LIST,
                          TPL_HAS_SMOOTH_FALSE, TPL_HAS_SMOOTH_TRUE),
    ASCENDC_TPL_UINT_DECL(isSymmetrical, 1, ASCENDC_TPL_UI_LIST,
                          TPL_IS_SYMMERTRICAL_FALSE, TPL_IS_SYMMERTRICAL_TRUE));

ASCENDC_TPL_SEL(
    // 1. COMMON_FULL_LOAD : 2*1*2*2
    ASCENDC_TPL_ARGS_SEL(
        ASCENDC_TPL_UINT_SEL(useDb, ASCENDC_TPL_UI_LIST, TPL_USE_DB_FALSE, TPL_USE_DB_TRUE),
        ASCENDC_TPL_UINT_SEL(quantMode, ASCENDC_TPL_UI_LIST, TPL_COMMON_FULL_LOAD),
        ASCENDC_TPL_UINT_SEL(hasSmooth, ASCENDC_TPL_UI_LIST,
                             TPL_HAS_SMOOTH_FALSE, TPL_HAS_SMOOTH_TRUE),
        ASCENDC_TPL_UINT_SEL(isSymmetrical, ASCENDC_TPL_UI_LIST,
                             TPL_IS_SYMMERTRICAL_FALSE, TPL_IS_SYMMERTRICAL_TRUE)
    ),
    // 2. COMMON_LARGE_SHAPE : 1*1*2*2
    ASCENDC_TPL_ARGS_SEL(
        ASCENDC_TPL_UINT_SEL(useDb, ASCENDC_TPL_UI_LIST, TPL_USE_DB_TRUE),
        ASCENDC_TPL_UINT_SEL(quantMode, ASCENDC_TPL_UI_LIST, TPL_COMMON_LARGE_SHAPE),
        ASCENDC_TPL_UINT_SEL(hasSmooth, ASCENDC_TPL_UI_LIST,
                             TPL_HAS_SMOOTH_FALSE, TPL_HAS_SMOOTH_TRUE),
        ASCENDC_TPL_UINT_SEL(isSymmetrical, ASCENDC_TPL_UI_LIST,
                             TPL_IS_SYMMERTRICAL_FALSE, TPL_IS_SYMMERTRICAL_TRUE)
    ),
    // 3. MOE : 2*2*1*2
    ASCENDC_TPL_ARGS_SEL(
        ASCENDC_TPL_UINT_SEL(useDb, ASCENDC_TPL_UI_LIST, TPL_USE_DB_FALSE, TPL_USE_DB_TRUE),
        ASCENDC_TPL_UINT_SEL(quantMode, ASCENDC_TPL_UI_LIST,
                             TPL_MOE_FULL_LOAD, TPL_MOE_LARGE_SHAPE),
        ASCENDC_TPL_UINT_SEL(hasSmooth, ASCENDC_TPL_UI_LIST, TPL_HAS_SMOOTH_TRUE),
        ASCENDC_TPL_UINT_SEL(isSymmetrical, ASCENDC_TPL_UI_LIST,
                             TPL_IS_SYMMERTRICAL_FALSE, TPL_IS_SYMMERTRICAL_TRUE)
    ),
    // 4. TPL_PER_TENSOR_FULL_LOAD : 2*1*2*2
    ASCENDC_TPL_ARGS_SEL(
        ASCENDC_TPL_UINT_SEL(useDb, ASCENDC_TPL_UI_LIST, TPL_USE_DB_FALSE, TPL_USE_DB_TRUE),
        ASCENDC_TPL_UINT_SEL(quantMode, ASCENDC_TPL_UI_LIST, TPL_PER_TENSOR_FULL_LOAD),
        ASCENDC_TPL_UINT_SEL(hasSmooth, ASCENDC_TPL_UI_LIST,
                             TPL_HAS_SMOOTH_FALSE, TPL_HAS_SMOOTH_TRUE),
        ASCENDC_TPL_UINT_SEL(isSymmetrical, ASCENDC_TPL_UI_LIST,
                             TPL_IS_SYMMERTRICAL_FALSE, TPL_IS_SYMMERTRICAL_TRUE)
    ),
    // 5. TPL_PER_TENSOR_LARGE_SHAPE : 1*1*2*2
    ASCENDC_TPL_ARGS_SEL(
        ASCENDC_TPL_UINT_SEL(useDb, ASCENDC_TPL_UI_LIST, TPL_USE_DB_TRUE),
        ASCENDC_TPL_UINT_SEL(quantMode, ASCENDC_TPL_UI_LIST, TPL_PER_TENSOR_LARGE_SHAPE),
        ASCENDC_TPL_UINT_SEL(hasSmooth, ASCENDC_TPL_UI_LIST,
                             TPL_HAS_SMOOTH_FALSE, TPL_HAS_SMOOTH_TRUE),
        ASCENDC_TPL_UINT_SEL(isSymmetrical, ASCENDC_TPL_UI_LIST,
                             TPL_IS_SYMMERTRICAL_FALSE, TPL_IS_SYMMERTRICAL_TRUE)
    ),
    // 6. EMPTY_TENSOR : 1*1*1*1
    ASCENDC_TPL_ARGS_SEL(
        ASCENDC_TPL_UINT_SEL(useDb, ASCENDC_TPL_UI_LIST, TPL_USE_DB_FALSE),
        ASCENDC_TPL_UINT_SEL(quantMode, ASCENDC_TPL_UI_LIST, TPL_EMPTY_TENSOR),
        ASCENDC_TPL_UINT_SEL(hasSmooth, ASCENDC_TPL_UI_LIST, TPL_HAS_SMOOTH_FALSE),
        ASCENDC_TPL_UINT_SEL(isSymmetrical, ASCENDC_TPL_UI_LIST, TPL_IS_SYMMERTRICAL_FALSE)
    )
);

}  // namespace DynamicQuantOp

#endif  // _DYNAMIC_QUANT_STRUCT_H_